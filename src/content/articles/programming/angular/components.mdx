---
title: Components
description: Components in Angular SPA framework
tags:
  [
    "angular",
    "spa",
    "js",
    "ts",
    "component",
    "reusable",
    "binding",
    "lifecycle",
    "two-way",
    "standalone",
  ]
lang: en-US
---

import { Image } from "astro:assets";

# Components

Components are the building blocks of Angular applications. Usually we have the `AppComponent`, which is the root of the app. Each component
is split into 4 files:

- HTML
- CSS
- TypeScript
- tests

Usually, each component has its own folder. We store them in the `app` folder
(that is pregenerated by `ng new`) or some subfolders of it.

## Standalone Components

Angular uses standalone components as the default approach. This eliminates the need for NgModules and their boilerplate code, making Angular more similar to React or Vue.js.

Here's the simplest component:

```ts
import { Component } from "@angular/core";

@Component({
  selector: "app-root",
  templateUrl: "./app.component.html",
  styleUrls: ["./app.component.css"],
})
export class AppComponent {}
```

Angular promotes the separation of things into different files, opposed to
frameworks like Vue.js. However, we are able to have HTML/CSS in the `ts` file
simply by replacing `templateUrl`/`styleUrls` with `template`/`styles` and
providing the HTML or CSS there as a string.

### Using Components in Other Components

To use a standalone component in another component, import it in the `imports` array:

```ts
@Component({
  imports: [MyComponent],
  selector: "app-my-other-component",
  templateUrl: "./my-other-component.component.html",
})
export class MyOtherComponent {}
```

This approach is very similar to how you'd do it in Vue.js.

### Importing Modules

Standalone components can import not only other standalone components, but also whole modules. This is useful when your app uses entities that are exported by modules:

```ts
@Component({
  imports: [CommonModule, FormsModule, MyComponent],
  selector: "app-my-component",
  templateUrl: "./my-component.component.html",
})
export class MyComponent {}
```

If a standalone component is the only thing that uses an imported module, that module doesn't need to be imported anywhere else.

### Bootstrapping Applications

With standalone components, you can eliminate the `AppModule` entirely. Instead of bootstrapping with a module, use `bootstrapApplication`:

```ts
bootstrapApplication(AppComponent);
```

### Dependency Injection

Without modules, you need a different way to provide services globally. Use the second parameter of `bootstrapApplication`:

```ts
bootstrapApplication(AppComponent, {
  providers: [MyService],
});
```

This makes `MyService` available globally throughout your application (although it's recommended to
provide them in `root`).

### Routing and Lazy Loading

Lazy loading uses the `loadComponent` function in your routes:

```ts
const routes: Routes = [
  {
    path: "feature",
    loadComponent: () =>
      import("./feature/feature.component").then((m) => m.FeatureComponent),
  },
];
```

The `loadChildren` function is still useful for loading files containing child routes instead of modules.

## selector

The selector is usually prefixed with `app-` to keep us from overwriting HTML
tags.

The `selector` does not have to be an HTML tag. It can also be an attribute or a
class:

- `selector: 'app-root'` - it will match HTML elements `<app-root></app-root>`.
- `selector: '[app-root]'` - it will match any HTML element with that attribue,
  e.g. `<div app-root></div>`.
- `selector: '.app-root'` - it will match any HTML element that has the
  `app-root` class on it, e.g. `<div class="app-root"></div>`.

The `selector` property is actually not just the way to name the component. It
is a specifier of where to render it. It's kind of similar to Kubernetes'
Service object and its `selector`, which specifies where to send the traffic.

Most often we just specify our own tag for the component.

## Data Binding

### Output

We can output data with:

```html
{{ something }}
```

The variable to output needs to exist on the component:

```ts
@Component({
  selector: "app-component",
  templateUrl: "./app.component.html",
})
export class AppComponent {
  something = 10;
}
```

:::tip
Inside of `{{}}` you can actually have any JS/TS expression, like a call to some
method.

It can't contain `if` condition though.
:::

### Property Binding

```html
<button [disabled]="!allowNewServer">Add Server</button>
```

The `disabled` property of a button is controlled by the `allowNewServer`
property on our component:

```ts
@Component({
  selector: "app-servers",
  templateUrl: "./servers.component.html",
  styleUrls: ["./servers.component.css"],
})
export class ServersComponent implements OnInit {
  allowNewServer = false;
}
```

:::tip[innerText]
Every tag has `innerText` property, which sets the content of the tag, e.g.:

```html
<p [innerText]="Content"></p>
```

produces

```html
<p>Content</p>
```

The `{{}}` would also work.
:::

:::caution[Brackets vs. no brackets]
We don't always have to provide square brackets when binding to some input.

If brackets are there, the value is treated as an expression.

If there are no brackets the value is treated as a string.
:::

#### Two-way Binding

In forms, it is useful to bind in two-ways, so that we can control the contents
of the input and also read that content.

Here's an example:

```html
<input type="text" [(ngModel)]="username" />
```

I am able to access `username` in the TS code and I am also able to modify it.

## Events

We can bind to "native" events with `(event)="expression"`. For example:

```html
<button (click)="onButtonClick()">Add</button>
```

The `onButtonClick` method would have to exist on our component. We could also
put some expression directly in the HTML instead of invoking a method.

### Event Details

We can pass an object with event details by including `$event`:

```html
<button (click)="onButtonClick($event)">Add</button>
```

### Custom Events

Our comonents can emit custom events that the parent of the component can
handle:

```ts {3,6}
@Component(...)
export class MyComponent {
    userCreated = output<User>();

    someMethod() {
        this.userCreated.emit({name: 'Greg', age: 22});
    }
}
```

The parent comonent would attach to that event like this:

```html
<app-my-component (userCreated)="onUserCreated($event)"></ap-my-component>
```

The `onUserCreated` would be some method defined on that parent. The `$event`
would be the instance of `User` the `MyComponent` passed to the event.

:::tip
`output` must be imported from `@angular/core`.
:::

We can alias the name of the event similarly to how we can do that in **Inputs**
that I will describe next.

## Inputs

In order to allow our components to accept "arguments", we need to define them,
like this:

```ts {3}
@Component(...)
export class MyComponent {
    name = input<string>();
}
```

The parent component would pass data into `MyComponent` like this:

```html
<app-my-component [name]="Steve"></app-my-component>
```

:::tip[Aliasing]
We can change the property's name that the parent sees with:

```ts
name = input<string>({ alias: "username" });
```

Now, the parent has to bind to `username`, not `name`:

```html
<app-my-component [username]="Steve"></app-my-component>
```

:::

## Accepting Children

Our components may display some children that would be passed by the parent
component. Here's how to do that.

The component that accepts children needs to have this somewhere in its
template:

```html
<ng-content></ng-content>
```

The children would be passed like that:

```html
<app-some-component>
  <p>I am being passed into SomeComponent!</p>
</app-some-component>
```

If a component does not define `<ng-content>` anywhere in its template, any
content that we pass into it is just lost.

### @ViewContent

We might need to access some HTML element that is passed to our component as a
child. We can't do that with [@ViewChild](/programming/angular/tips#viewchild),
because it can only be used for elements that belong to our component directly.
There's another decorator though - `@ViewContent`.

Here's an example:

From the parent we pass some child into `SomeComponent`:

```html
<app-some-component>
  <p #paragraph>Bla bla bla</p>
</app-some-component>
```

From the `SomeComponent` (that received the paragraph into its `<ng-content>`):

```ts
// The property can be called whatever we want
@ViewContent('paragraph') paragraph: ElementRef;
```

:::caution
If you're about to use the `ElementRef` from the `ngOnInit` hook, you should add
`{ static: true }`:

```ts
@ViewContent('paragraph', { static: true }) paragraph: ElementRef;
```

I don't really know why you'd even want to do that since the target element
would not be even initialized yet. It will be initialized in the
`ngAfterContentInit` though.
:::

## Component Lifecycle

- `ngOnInit` - fired once the component is initialized. It's not yet displayed,
  but the object for it was created in memory (the constructor finished its
  execution at this point). Accessing DOM elements from here (e.g. via
  [references](/programming/angular/tips#references-to-html-elements)) might not give us the
  expected result since they might not be initialized yet. It's better to use
  `ngAfterViewInit` for that.
- `ngOnChanges` - fired when the component is initialized and also each time any
  input property is modified. It is the only hook that
  receives an argument - these are the changes that Angular found (with current
  and previous values).
- `ngDoCheck` - run whenever Angular checks for changes in the component. Even
  if nothing really changed, Angular has to check it first, and this method will
  be called. The change detection is triggered by various things: events,
  Promise resolution and others.
- `ngAfterContentInit` - called when the child passed to this component gets
  initialized (`<ng-content>`).
- `ngAfterContentChecked` - fired when the Angular's change detection finishes
  checking the child component.
- `ngAfterViewInit` - fired when the component gets rendered on the screen
- `ngAfterViewChecked` - fired when the view (including children) has been
  checked by Angular.
- `ngOnDestroy` - called once the component is about to be destroyed.

:::tip[Imports]
Each lifecycle method implementation requires our component to implement a
specific type. For example, `ngOnInit` requires `OnInit` to be implemented.
:::

## Instantiating Components from TypeScript

Normally, we include all the components that we want to render in our template
`.html` files. However, in more dynamic scenarios, it might be impossible to
know upfront which components will be needed on a given page. That's where
**Dynamic Components** might be used. We're able to create components within our
TypeScript code and render them on the page.

Here's how to do it:
[StackOverflow](https://stackoverflow.com/questions/70946038/replace-deprecated-angular-componentfactoryresolver-componentfactory).

In Angular \<13, we'd use `ComponentFactoryResolver`. Nowadays, it's deprecated.

